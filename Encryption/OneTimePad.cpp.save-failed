#include "OneTimePad.h"

OTPEngine::OTPEngine(int min,int max){
    _randomEngine = make_unique<Random<int>>(min,max);
    _write = make_unique<std::ofstream>();
    _read = make_unique<std::ifstream>();

}

void OTPEngine::reroll(int length){
    _values = new OneTimePad;
    if(_values){
        _values->clear(); // Erase OTP
    }
    _string.clear(); // Erase string
    for(int c = 0;c < length;++c){
        _convert.str(std::string());
        int currentValue = _randomEngine->next();
        _values.push_back(currentValue);
        _convert << currentValue;
        _string += (_convert.str() + " ");
    }
    _values->
}

std::string OTPEngine::decode(const std::string &str){
    std::string finalString = str;
    for(int i = 0;i < str.size();++i){
        finalString[i] = (char)str[i] - _values[i];
        if(finalString[i] > 128){
            finalString[i] = 0;
        }
    }
    return finalString;
}
std::string OTPEngine::encode(const std::string &str){
    std::string finalString = str;
    int index = 0;
    for(int i = 0;i < str.size();++i){
        finalString[i] = (char)str[i] + _values[i];
        if(finalString[i] > 128){
            finalString[i] = 0;
        }
    }
    //std::cout << finalString << std::endl;
    return finalString;
}

void OTPEngine::encodeFile(const std::string &path){
    _read->open(path,std::ios::binary); // Open file for writing.

    if(!*_read){ //If opening the file failed,
        throw std::runtime_error("Could not open file \"" + path + "\" to encode."); //throw an exception.
    }

    std::string finalContents = ""; // String to store final (encrypted) contents of file.
    char currentChar; // Character to store current character being read by file stream.

    while(_read->get(currentChar)){ // While there are still characters of the file to read...
        std::cout << "Encoding character: \'" << currentChar << "\'"<< std::endl;
        finalContents += (char)(currentChar + _values[_read->tellg()]); // Encrypt the current character and add it to the final string
        std::cout << "Char #: " << _read->tellg() << std::endl;
    }

    int fileSize = _read->tellg(); // Get size of file in bytes.

    //_read->seekg(0,std::ios::cur);
    int finalCharAmount = _read->tellg(); // Variable to store the final amount of encrypted characters.


    std::cout << "Successfully encrypted " << path << std::endl;
    /* Writing new contents to file */
    _write->open(path); // Open file for writing (Consequentially erasing the file)
    *_write << finalContents; // Fill the empty file with the new contents
    _write->close();

    _read->close(); // Stop reading file.
}

int OTPEngine::decodeFile(const std::string &path){
    _read->open(path,std::ios::binary); //Open file to decode.

    if(!*_read){ //If opening the file failed,
        throw std::invalid_argument("Could not open file \"" + path + "\" to decode."); //throw an exception.
    }

    std::string newContent = ""; // Variable to store new file content.
    char currentChar; // Character to store current character being read by file stream.
    unsigned int currentIndex = 0; // Current character in file.

    while(*_read >> currentChar){
        newContent += (char)((int)currentChar - _values[_read->tellg()]);
    }
    _read->close();

    _write->open(path);
    *_write << newContent;
    _write->close();
    std::cout << "Successfully decrypted file \"" << path << "\"\nResults:\n" << newContent << std::endl;
}

int OTPEngine::decodeFileBits(const std::string &path){
    _read->open(path);
    char currentChar;

    while(*_read >> currentChar){

    }
}

const std::string &OTPEngine::getString(){
    //_string.
    return _string;
}

const std::vector<char> &OTPEngine::getCurrentValues(){
    return _values;
}

OTPEngine::~OTPEngine(){

}
